use sea_orm::entity::prelude::*;

#[sea_orm(table_name = "mytable")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    pub desc: String,
}

/// Generated by sea-orm-macros
pub enum Column {
    /// Generated by sea-orm-macros
    Id,
    /// Generated by sea-orm-macros
    Name,
    /// Generated by sea-orm-macros
    Desc,
}

#[automatically_derived]
impl Column {
    fn default_as_str(&self) -> &str {
        match self {
            Self::Id => "id",
            Self::Name => "name",
            Self::Desc => "desc",
        }
    }
}

// TODO(babman): IMPORTANT. For bbox<T> ---> T
#[automatically_derived]
impl sea_orm::prelude::ColumnTrait for Column {
    type EntityName = Entity;
    fn def(&self) -> sea_orm::prelude::ColumnDef {
        match self {
            Self::Id => {
                sea_orm::prelude::ColumnTypeTrait::def(
                    sea_orm::prelude::ColumnType::Integer,
                )
            }
            Self::Name => {
                sea_orm::prelude::ColumnTypeTrait::def(
                    sea_orm::prelude::ColumnType::String(None),
                )
            }
            Self::Desc => {
                sea_orm::prelude::ColumnTypeTrait::def(
                    sea_orm::prelude::ColumnType::String(None),
                )
            }
        }
    }
    fn select_as(
        &self,
        expr: sea_orm::sea_query::Expr,
    ) -> sea_orm::sea_query::SimpleExpr {
        match self {
            _ => sea_orm::prelude::ColumnTrait::select_enum_as(self, expr),
        }
    }
    fn save_as(&self, val: sea_orm::sea_query::Expr) -> sea_orm::sea_query::SimpleExpr {
        match self {
            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
        }
    }
}

/// Generated by sea-orm-macros
pub struct Entity;

#[automatically_derived]
impl sea_orm::entity::EntityTrait for Entity {
    type Model = Model;
    type Column = Column;
    type PrimaryKey = PrimaryKey;
    type Relation = Relation;
}


/// Generated by sea-orm-macros
pub enum PrimaryKey {
    /// Generated by sea-orm-macros
    Id,
}


// TODO(babman): important: this is how we get it!
#[automatically_derived]
impl sea_orm::FromQueryResult for Model {
    fn from_query_result(
        row: &sea_orm::QueryResult,
        pre: &str,
    ) -> std::result::Result<Self, sea_orm::DbErr> {
        Ok(Self {
            id: row
                .try_get(
                    pre,
                    sea_orm::IdenStatic::as_str(
                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Id,
                        )
                        .into(),
                )?,
            name: row
                .try_get(
                    pre,
                    sea_orm::IdenStatic::as_str(
                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Name,
                        )
                        .into(),
                )?,
            desc: row
                .try_get(
                    pre,
                    sea_orm::IdenStatic::as_str(
                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Desc,
                        )
                        .into(),
                )?,
        })
    }
}

// TODO(babman): maybe important.
#[automatically_derived]
impl sea_orm::ModelTrait for Model {
    type Entity = Entity;
    fn get(
        &self,
        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
    ) -> sea_orm::Value {
        match c {
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                self.id.clone().into()
            }
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                self.name.clone().into()
            }
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Desc => {
                self.desc.clone().into()
            }
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("field does not exist on Model"),
                );
            }
        }
    }
    fn set(
        &mut self,
        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
        v: sea_orm::Value,
    ) {
        match c {
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                self.id = v.unwrap();
            }
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                self.name = v.unwrap();
            }
            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Desc => {
                self.desc = v.unwrap();
            }
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("field does not exist on Model"),
                );
            }
        }
    }
}

// TODO(babman): need to do something about this.
/// Generated by sea-orm-macros
pub struct ActiveModel {
    /// Generated by sea-orm-macros
    pub id: sea_orm::ActiveValue<i32>,
    /// Generated by sea-orm-macros
    pub name: sea_orm::ActiveValue<String>,
    /// Generated by sea-orm-macros
    pub desc: sea_orm::ActiveValue<String>,
}

#[automatically_derived]
impl std::convert::From<<Entity as EntityTrait>::Model> for ActiveModel {
    fn from(m: <Entity as EntityTrait>::Model) -> Self {
        Self {
            id: sea_orm::ActiveValue::unchanged(m.id),
            name: sea_orm::ActiveValue::unchanged(m.name),
            desc: sea_orm::ActiveValue::unchanged(m.desc),
        }
    }
}

#[automatically_derived]
impl sea_orm::IntoActiveModel<ActiveModel> for <Entity as EntityTrait>::Model {
    fn into_active_model(self) -> ActiveModel {
        self.into()
    }
}

#[automatically_derived]
impl sea_orm::ActiveModelTrait for ActiveModel {
    type Entity = Entity;
    fn take(
        &mut self,
        c: <Self::Entity as EntityTrait>::Column,
    ) -> sea_orm::ActiveValue<sea_orm::Value> {
        match c {
            <Self::Entity as EntityTrait>::Column::Id => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.id);
                value.into_wrapped_value()
            }
            <Self::Entity as EntityTrait>::Column::Name => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.name);
                value.into_wrapped_value()
            }
            <Self::Entity as EntityTrait>::Column::Desc => {
                let mut value = sea_orm::ActiveValue::not_set();
                std::mem::swap(&mut value, &mut self.desc);
                value.into_wrapped_value()
            }
            _ => sea_orm::ActiveValue::not_set(),
        }
    }
    fn get(
        &self,
        c: <Self::Entity as EntityTrait>::Column,
    ) -> sea_orm::ActiveValue<sea_orm::Value> {
        match c {
            <Self::Entity as EntityTrait>::Column::Id => {
                self.id.clone().into_wrapped_value()
            }
            <Self::Entity as EntityTrait>::Column::Name => {
                self.name.clone().into_wrapped_value()
            }
            <Self::Entity as EntityTrait>::Column::Desc => {
                self.desc.clone().into_wrapped_value()
            }
            _ => sea_orm::ActiveValue::not_set(),
        }
    }
    fn set(&mut self, c: <Self::Entity as EntityTrait>::Column, v: sea_orm::Value) {
        match c {
            <Self::Entity as EntityTrait>::Column::Id => {
                self.id = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as EntityTrait>::Column::Name => {
                self.name = sea_orm::ActiveValue::set(v.unwrap());
            }
            <Self::Entity as EntityTrait>::Column::Desc => {
                self.desc = sea_orm::ActiveValue::set(v.unwrap());
            }
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("This ActiveModel does not have this field"),
                );
            }
        }
    }
    fn not_set(&mut self, c: <Self::Entity as EntityTrait>::Column) {
        match c {
            <Self::Entity as EntityTrait>::Column::Id => {
                self.id = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as EntityTrait>::Column::Name => {
                self.name = sea_orm::ActiveValue::not_set();
            }
            <Self::Entity as EntityTrait>::Column::Desc => {
                self.desc = sea_orm::ActiveValue::not_set();
            }
            _ => {}
        }
    }
    fn is_not_set(&self, c: <Self::Entity as EntityTrait>::Column) -> bool {
        match c {
            <Self::Entity as EntityTrait>::Column::Id => self.id.is_not_set(),
            <Self::Entity as EntityTrait>::Column::Name => self.name.is_not_set(),
            <Self::Entity as EntityTrait>::Column::Desc => self.desc.is_not_set(),
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("This ActiveModel does not have this field"),
                );
            }
        }
    }
    fn default() -> Self {
        Self {
            id: sea_orm::ActiveValue::not_set(),
            name: sea_orm::ActiveValue::not_set(),
            desc: sea_orm::ActiveValue::not_set(),
        }
    }
    fn reset(&mut self, c: <Self::Entity as EntityTrait>::Column) {
        match c {
            <Self::Entity as EntityTrait>::Column::Id => self.id.reset(),
            <Self::Entity as EntityTrait>::Column::Name => self.name.reset(),
            <Self::Entity as EntityTrait>::Column::Desc => self.desc.reset(),
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("This ActiveModel does not have this field"),
                );
            }
        }
    }
}

#[automatically_derived]
impl std::convert::TryFrom<ActiveModel> for <Entity as EntityTrait>::Model {
    type Error = sea_orm::DbErr;
    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
        if match a.id {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("id".to_owned()));
        }
        if match a.name {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("name".to_owned()));
        }
        if match a.desc {
            sea_orm::ActiveValue::NotSet => true,
            _ => false,
        } {
            return Err(sea_orm::DbErr::AttrNotSet("desc".to_owned()));
        }
        Ok(Self {
            id: a.id.into_value().unwrap().unwrap(),
            name: a.name.into_value().unwrap().unwrap(),
            desc: a.desc.into_value().unwrap().unwrap(),
        })
    }
}

#[automatically_derived]
impl sea_orm::TryIntoModel<<Entity as EntityTrait>::Model> for ActiveModel {
    fn try_into_model(self) -> Result<<Entity as EntityTrait>::Model, sea_orm::DbErr> {
        self.try_into()
    }
}

pub enum Relation {}

///An iterator over the variants of [Relation]
#[allow(missing_copy_implementations)]
pub struct RelationIter {
    idx: usize,
    back_idx: usize,
    marker: ::core::marker::PhantomData<()>,
}
impl core::fmt::Debug for RelationIter {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("RelationIter").field("len", &self.len()).finish()
    }
}
impl RelationIter {
    fn get(&self, idx: usize) -> Option<Relation> {
        match idx {
            _ => ::core::option::Option::None,
        }
    }
}
impl sea_orm::strum::IntoEnumIterator for Relation {
    type Iterator = RelationIter;
    fn iter() -> RelationIter {
        RelationIter {
            idx: 0,
            back_idx: 0,
            marker: ::core::marker::PhantomData,
        }
    }
}
impl Iterator for RelationIter {
    type Item = Relation;
    fn next(&mut self) -> Option<<Self as Iterator>::Item> {
        self.nth(0)
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        let t = if self.idx + self.back_idx >= 0usize {
            0
        } else {
            0usize - self.idx - self.back_idx
        };
        (t, Some(t))
    }
    fn nth(&mut self, n: usize) -> Option<<Self as Iterator>::Item> {
        let idx = self.idx + n + 1;
        if idx + self.back_idx > 0usize {
            self.idx = 0usize;
            ::core::option::Option::None
        } else {
            self.idx = idx;
            self.get(idx - 1)
        }
    }
}
impl ExactSizeIterator for RelationIter {
    fn len(&self) -> usize {
        self.size_hint().0
    }
}
impl DoubleEndedIterator for RelationIter {
    fn next_back(&mut self) -> Option<<Self as Iterator>::Item> {
        let back_idx = self.back_idx + 1;
        if self.idx + back_idx > 0usize {
            self.back_idx = 0usize;
            ::core::option::Option::None
        } else {
            self.back_idx = back_idx;
            self.get(0usize - self.back_idx)
        }
    }
}

#[automatically_derived]
impl sea_orm::entity::RelationTrait for Relation {
    fn def(&self) -> sea_orm::entity::RelationDef {
        match self {
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!("No RelationDef for Relation"),
                );
            }
        }
    }
}

impl ActiveModelBehavior for ActiveModel {}


fn main() {
    {
        ::std::io::_print(format_args!("RUN!\n"));
    };
}
